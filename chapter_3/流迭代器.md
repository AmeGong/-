
## iostream迭代器
虽然iostream类型不是容器，但是标准库定义了可以用于这些IO类型对象的迭代器
### isteam_iterator读取输入流
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。
因为istream_iterator使用>>来读取流。因此，istream_iterator要读取的类型必须定义了输入操作符。
#### 可以把流理解为一个容器。输入流就是一个不知道大小的容器。

#### 创建一个istream_iterator:
创建一个istream_iterator时，我们可以将它绑定到一个流上。
```
istream_iterator<int> int_it(cin); //将输入迭代器绑定到标准输入cin上，从标准输入读取int数据
istream_iterator<int> int_eof; //int_eof被定义为空的迭代器，从而可以被当作尾后迭代器。
                              //一旦关联的流遇到文件尾或者遇到IO错误，迭代器的值就和尾后迭代器相同
while(int_it!=int_eof) // 不断从标准输入读取int数据，指导遇到错误或者文件结束符  
{
  cout<<*int_it<<" "; //输出迭代器的值
  }
```
 
#### 创建一个ostream_iterator:
创建一个ostream_iterator时，我们可以提供（可选的）第二个参数，他是一个字符串，在输出每个元素后都会打印此字符串，此字符串必须是C风格字符串
```
ostream_iterator<int> out_iter(cout," ); //每个元素后加一个空格
```
同样创建一个ostream_iterator时，需要将其绑定在一个指定的流上
但是不允许空的或者表示尾后的ostream_iterator.
```
ostream_iterator<int> out_iter(cout," "); //将输入迭代器绑定到标准输出cout上，在输出每个元素后都会打印一个空格
for(auto e:vec)
  *out_iter++ = e; //等价于*out_iter = e; out_iter++;
                   //*out_iter = e;表示将e写道输出流cout中
```
