## 类似与指针，迭代器也提供了对对象的简介访问。
迭代器的begin和end成员。
```
begin：返回第一个元素的迭代器。 auto b = v.begin()
end:返回容器尾元素的下一个位置。 auto e = v.end()  //note：end并不实际指示，某个元素，所以不能对其进行递增或解引用操作
```
```
*b:返回迭代器b所指元素的应用
b->mem：借应用b并获得元素名为mem的成员，等价与（*b）.mem
++b:令b指向容器的下一个元素
```

## 插入迭代器（back_inserter,front_inserter,inserter）
### inserter:
```
inserter(c,iterator) //inserter创建一个使用insert的迭代器，第一个参数是被插入的容器，第二个参数是给定容器的一个迭代器。
                     元素将被插入到给定迭代器表示的元素之前
```

```
vector<int> vi;
it = inserter(vi,vi.begin()); //创建插入迭代器
*it = val;                       //对插入迭代器赋值，进行插入，把1插入到vi.begin()迭代器之前     
                              // 并且插入迭代器会自动加一，插入结束后依然指向插入之前的元素
```
以上代码等价于一下代码：
```
it = c.insert(vi,val);  //insert方法会返回一个指向插入元素的迭代器
++it;                   //重新让it指向原来的元素
```

### front_inserter:
front_insert总是将元素插入到容器的第一个元素之前，所以我们只需要向front_inserter传递一个容器参数即可。该容器要支持push_front()
```
fi = front_inserter(vi);
fi = val;                 //vi的首元素变为val
```

### back_inserter:
与front_inserter相反，总是将元素插入到容器的最后一个元素之后。

## iostream迭代器
虽然iostream类型不是容器，但是标准库定义了可以用于这些IO类型对象的迭代器
### isteam_iterator读取输入流
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。
因为istream_iterator使用>>来读取流。因此，istream_iterator要读取的类型必须定义了输入操作符。
#### 可以把流理解为一个容器。输入流就是一个不知道大小的容器。

#### 创建一个istream_iterator:
创建一个istream_iterator时，我们可以将它绑定到一个流上。
```
istream_iterator<int> int_it(cin); //将输入迭代器绑定到标准输入cin上，从标准输入读取int数据
istream_iterator<int> int_eof; //int_eof被定义为空的迭代器，从而可以被当作尾后迭代器。
                              //一旦关联的流遇到文件尾或者遇到IO错误，迭代器的值就和尾后迭代器相同
while(int_it!=int_eof) // 不断从标准输入读取int数据，指导遇到错误或者文件结束符  
{
  cout<<*int_it<<" "; //输出迭代器的值
  }
```
 
#### 创建一个ostream_iterator:
创建一个ostream_iterator时，我们可以提供（可选的）第二个参数，他是一个字符串，在输出每个元素后都会打印此字符串，此字符串必须是C风格字符串
```
ostream_iterator<int> out_iter(cout," ); //每个元素后加一个空格
```
同样创建一个ostream_iterator时，需要将其绑定在一个指定的流上
但是不允许空的或者表示尾后的ostream_iterator.
```
ostream_iterator<int> out_iter(cout," "); //将输入迭代器绑定到标准输出cout上，在输出每个元素后都会打印一个空格
for(auto e:vec)
  *out_iter++ = e; //等价于*out_iter = e; out_iter++;
                   //*out_iter = e;表示将e写道输出流cout中
```
