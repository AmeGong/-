# 算法不会执行容器的操作，因此它们自身不可能改变容器的大小！！！
算法都是基于迭代器进行的操作，所以不会改变容器的大小。

## 拷贝算法
```
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];  //创建a2数组，大小与a1相同。sizeof()返回字节数。
auto ret = copy(begin(a1),end(a1),a2); //把a1的内容拷贝给a2，copy返回的其目的位置迭代器（递增后）的值。
                                        所以ret恰好指向拷贝到a2的尾后元素之后的位置。
```

## 排序算法
```
sort(c.begin(),c.end()); // 将容器c中的所有元素进行排序
stable_sort(c.begin,c.end()); // 将words按size排列，同时保持相对的字母顺序
```



## 使用unique
```
auto end_unique = unique(c.begin(),c.end()); // 将相邻的重复项“消除”，并且返回一个指向不重复值范围末尾的迭代器.
                                              unique并不真的删除元素，它只是覆盖相邻的重复元素，使不重复元素出现在序列开始部分，
                                              unique返回的迭代器指向第一个重复的元素
```

## find_if
```
auto wc = find_if(c.begin(),c.end(),谓词) // 返回第一个迭代器，该迭代器指向第一个满足谓词的元素.
// 具体如下
auto wc = find_if(c.begin(),c.end(),
  [sz](const string &a){return a.size()>=sz;})  //使用lambda作为谓词
```

## for_each算法
```
for_each(c.begi(),c.end(),谓词) //将c容器中的每个元素作为参数传递给谓词
// 具体如下
for_each(c.begi(),c.end(),  
  [](const string &s){cout<<s<<" ";});  //将c容器中的每个元素进行标准输出.
```
