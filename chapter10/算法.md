# 算法不会执行容器的操作，因此它们自身不可能改变容器的大小！！！
算法都是基于迭代器进行的操作，所以不会改变容器的大小。

## 拷贝算法
```
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)];  //创建a2数组，大小与a1相同。sizeof()返回字节数。
auto ret = copy(begin(a1),end(a1),a2); //把a1的内容拷贝给a2，copy返回的其目的位置迭代器（递增后）的值。
                                        所以ret恰好指向拷贝到a2的尾后元素之后的位置。
```

## 排序算法
```
sort(c.begin(),c.end()); // 将容器c中的所有元素进行排序
stable_sort(c.begin,c.end()); // 将words按size排列，同时保持相对的字母顺序
```



## 使用unique
```
auto end_unique = unique(c.begin(),c.end()); // 将相邻的重复项“消除”，并且返回一个指向不重复值范围末尾的迭代器.
                                              unique并不真的删除元素，它只是覆盖相邻的重复元素，使不重复元素出现在序列开始部分，
                                              unique返回的迭代器指向第一个重复的元素
```
